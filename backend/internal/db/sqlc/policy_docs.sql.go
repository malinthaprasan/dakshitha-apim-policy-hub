// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: policy_docs.sql

package sqlc

import (
	"context"
)

const getPolicyDoc = `-- name: GetPolicyDoc :one
SELECT id, policy_version_id, page, content_md, created_at, updated_at FROM policy_docs
WHERE policy_version_id = $1 AND page = $2
`

type GetPolicyDocParams struct {
	PolicyVersionID int32  `json:"policy_version_id"`
	Page            string `json:"page"`
}

func (q *Queries) GetPolicyDoc(ctx context.Context, arg GetPolicyDocParams) (PolicyDoc, error) {
	row := q.db.QueryRow(ctx, getPolicyDoc, arg.PolicyVersionID, arg.Page)
	var i PolicyDoc
	err := row.Scan(
		&i.ID,
		&i.PolicyVersionID,
		&i.Page,
		&i.ContentMd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPolicyDocs = `-- name: ListPolicyDocs :many
SELECT id, policy_version_id, page, content_md, created_at, updated_at FROM policy_docs
WHERE policy_version_id = $1
ORDER BY page
`

func (q *Queries) ListPolicyDocs(ctx context.Context, policyVersionID int32) ([]PolicyDoc, error) {
	rows, err := q.db.Query(ctx, listPolicyDocs, policyVersionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PolicyDoc{}
	for rows.Next() {
		var i PolicyDoc
		if err := rows.Scan(
			&i.ID,
			&i.PolicyVersionID,
			&i.Page,
			&i.ContentMd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPolicyDoc = `-- name: UpsertPolicyDoc :one
INSERT INTO policy_docs (
    policy_version_id,
    page,
    content_md,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, NOW(), NOW()
)
ON CONFLICT (policy_version_id, page)
DO UPDATE SET
    content_md = EXCLUDED.content_md,
    updated_at = NOW()
RETURNING id, policy_version_id, page, content_md, created_at, updated_at
`

type UpsertPolicyDocParams struct {
	PolicyVersionID int32  `json:"policy_version_id"`
	Page            string `json:"page"`
	ContentMd       string `json:"content_md"`
}

func (q *Queries) UpsertPolicyDoc(ctx context.Context, arg UpsertPolicyDocParams) (PolicyDoc, error) {
	row := q.db.QueryRow(ctx, upsertPolicyDoc, arg.PolicyVersionID, arg.Page, arg.ContentMd)
	var i PolicyDoc
	err := row.Scan(
		&i.ID,
		&i.PolicyVersionID,
		&i.Page,
		&i.ContentMd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
