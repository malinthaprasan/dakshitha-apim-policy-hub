// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: policy_versions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPoliciesByMultiple = `-- name: CountPoliciesByMultiple :one
SELECT COUNT(DISTINCT pv.policy_name) FROM policy_version pv
WHERE ($1::text = '' OR LOWER(pv.display_name) LIKE LOWER('%' || $1 || '%') OR LOWER(pv.description) LIKE LOWER('%' || $1 || '%'))
    AND ($2::text[] IS NULL OR array_length($2::text[], 1) = 0 OR EXISTS (SELECT 1 FROM unnest($2::text[]) AS cat WHERE pv.categories ? cat))
    AND ($3::text[] IS NULL OR array_length($3::text[], 1) = 0 OR pv.provider = ANY($3::text[]))
    AND ($4::text[] IS NULL or array_length($4::text[], 1) = 0 OR EXISTS (SELECT 1 FROM unnest($4::text[]) AS plat WHERE pv.supported_platforms ? plat))
`

type CountPoliciesByMultipleParams struct {
	Column1 string   `json:"column_1"`
	Column2 []string `json:"column_2"`
	Column3 []string `json:"column_3"`
	Column4 []string `json:"column_4"`
}

func (q *Queries) CountPoliciesByMultiple(ctx context.Context, arg CountPoliciesByMultipleParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPoliciesByMultiple,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPolicyVersions = `-- name: CountPolicyVersions :one
SELECT COUNT(*) FROM policy_version
WHERE policy_name = $1
`

func (q *Queries) CountPolicyVersions(ctx context.Context, policyName string) (int64, error) {
	row := q.db.QueryRow(ctx, countPolicyVersions, policyName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const filterPoliciesByMultiple = `-- name: FilterPoliciesByMultiple :many
WITH ranked_versions AS (
    SELECT 
        pv.id, pv.policy_name, pv.version, pv.is_latest, pv.display_name, pv.provider, pv.description, pv.categories, pv.tags, pv.logo_path, pv.banner_path, pv.supported_platforms, pv.release_date, pv.definition_yaml, pv.icon_path, pv.source_type, pv.source_url, pv.created_at, pv.updated_at,
        ROW_NUMBER() OVER (
            PARTITION BY pv.policy_name 
            ORDER BY 
                pv.is_latest DESC,
                pv.created_at DESC
        ) as version_rank
    FROM policy_version pv
    WHERE ($1::text = '' OR LOWER(pv.display_name) LIKE LOWER('%' || $1 || '%') OR LOWER(pv.description) LIKE LOWER('%' || $1 || '%'))
        AND ($2::text[] IS NULL OR array_length($2::text[], 1) = 0 OR EXISTS (SELECT 1 FROM unnest($2::text[]) AS cat WHERE pv.categories ? cat))
        AND ($3::text[] IS NULL OR array_length($3::text[], 1) = 0 OR pv.provider = ANY($3::text[]))
        AND ($4::text[] IS NULL OR array_length($4::text[], 1) = 0 OR EXISTS (SELECT 1 FROM unnest($4::text[]) AS plat WHERE pv.supported_platforms ? plat))
)
SELECT 
    id, policy_name, version, is_latest, display_name, provider, description, 
    categories, tags, logo_path, banner_path, supported_platforms, 
    release_date, definition_yaml, icon_path, source_type, source_url, 
    created_at, updated_at
FROM ranked_versions 
WHERE version_rank = 1
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type FilterPoliciesByMultipleParams struct {
	Column1 string   `json:"column_1"`
	Column2 []string `json:"column_2"`
	Column3 []string `json:"column_3"`
	Column4 []string `json:"column_4"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type FilterPoliciesByMultipleRow struct {
	ID                 int32              `json:"id"`
	PolicyName         string             `json:"policy_name"`
	Version            string             `json:"version"`
	IsLatest           pgtype.Bool        `json:"is_latest"`
	DisplayName        string             `json:"display_name"`
	Provider           string             `json:"provider"`
	Description        pgtype.Text        `json:"description"`
	Categories         []byte             `json:"categories"`
	Tags               []byte             `json:"tags"`
	LogoPath           pgtype.Text        `json:"logo_path"`
	BannerPath         pgtype.Text        `json:"banner_path"`
	SupportedPlatforms []byte             `json:"supported_platforms"`
	ReleaseDate        pgtype.Date        `json:"release_date"`
	DefinitionYaml     string             `json:"definition_yaml"`
	IconPath           pgtype.Text        `json:"icon_path"`
	SourceType         pgtype.Text        `json:"source_type"`
	SourceUrl          pgtype.Text        `json:"source_url"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FilterPoliciesByMultiple(ctx context.Context, arg FilterPoliciesByMultipleParams) ([]FilterPoliciesByMultipleRow, error) {
	rows, err := q.db.Query(ctx, filterPoliciesByMultiple,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FilterPoliciesByMultipleRow{}
	for rows.Next() {
		var i FilterPoliciesByMultipleRow
		if err := rows.Scan(
			&i.ID,
			&i.PolicyName,
			&i.Version,
			&i.IsLatest,
			&i.DisplayName,
			&i.Provider,
			&i.Description,
			&i.Categories,
			&i.Tags,
			&i.LogoPath,
			&i.BannerPath,
			&i.SupportedPlatforms,
			&i.ReleaseDate,
			&i.DefinitionYaml,
			&i.IconPath,
			&i.SourceType,
			&i.SourceUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctCategories = `-- name: GetDistinctCategories :many

SELECT DISTINCT jsonb_array_elements_text(categories) as category
FROM policy_version
WHERE categories IS NOT NULL AND jsonb_array_length(categories) > 0
ORDER BY category
`

// =============================================================================
// METADATA OPERATIONS
// =============================================================================
func (q *Queries) GetDistinctCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctPlatforms = `-- name: GetDistinctPlatforms :many
SELECT DISTINCT jsonb_array_elements_text(supported_platforms) as platform
FROM policy_version
WHERE supported_platforms IS NOT NULL AND jsonb_array_length(supported_platforms) > 0
ORDER BY platform
`

func (q *Queries) GetDistinctPlatforms(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctPlatforms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var platform string
		if err := rows.Scan(&platform); err != nil {
			return nil, err
		}
		items = append(items, platform)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctProviders = `-- name: GetDistinctProviders :many
SELECT DISTINCT provider
FROM policy_version
WHERE provider IS NOT NULL AND provider != ''
ORDER BY provider
`

func (q *Queries) GetDistinctProviders(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDistinctProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var provider string
		if err := rows.Scan(&provider); err != nil {
			return nil, err
		}
		items = append(items, provider)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPolicyVersion = `-- name: GetLatestPolicyVersion :one
SELECT id, policy_name, version, is_latest, display_name, provider, description, categories, tags, logo_path, banner_path, supported_platforms, release_date, definition_yaml, icon_path, source_type, source_url, created_at, updated_at FROM policy_version
WHERE policy_name = $1 AND is_latest = TRUE
`

func (q *Queries) GetLatestPolicyVersion(ctx context.Context, policyName string) (PolicyVersion, error) {
	row := q.db.QueryRow(ctx, getLatestPolicyVersion, policyName)
	var i PolicyVersion
	err := row.Scan(
		&i.ID,
		&i.PolicyName,
		&i.Version,
		&i.IsLatest,
		&i.DisplayName,
		&i.Provider,
		&i.Description,
		&i.Categories,
		&i.Tags,
		&i.LogoPath,
		&i.BannerPath,
		&i.SupportedPlatforms,
		&i.ReleaseDate,
		&i.DefinitionYaml,
		&i.IconPath,
		&i.SourceType,
		&i.SourceUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPolicyByName = `-- name: GetPolicyByName :one
SELECT id, policy_name, version, is_latest, display_name, provider, description, categories, tags, logo_path, banner_path, supported_platforms, release_date, definition_yaml, icon_path, source_type, source_url, created_at, updated_at FROM policy_version
WHERE policy_name = $1 AND is_latest = TRUE
`

func (q *Queries) GetPolicyByName(ctx context.Context, policyName string) (PolicyVersion, error) {
	row := q.db.QueryRow(ctx, getPolicyByName, policyName)
	var i PolicyVersion
	err := row.Scan(
		&i.ID,
		&i.PolicyName,
		&i.Version,
		&i.IsLatest,
		&i.DisplayName,
		&i.Provider,
		&i.Description,
		&i.Categories,
		&i.Tags,
		&i.LogoPath,
		&i.BannerPath,
		&i.SupportedPlatforms,
		&i.ReleaseDate,
		&i.DefinitionYaml,
		&i.IconPath,
		&i.SourceType,
		&i.SourceUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPolicyVersion = `-- name: GetPolicyVersion :one


SELECT id, policy_name, version, is_latest, display_name, provider, description, categories, tags, logo_path, banner_path, supported_platforms, release_date, definition_yaml, icon_path, source_type, source_url, created_at, updated_at FROM policy_version
WHERE policy_name = $1 AND version = $2
`

type GetPolicyVersionParams struct {
	PolicyName string `json:"policy_name"`
	Version    string `json:"version"`
}

// All PolicyVersion queries - single table architecture
// =============================================================================
// BASIC POLICY VERSION OPERATIONS
// =============================================================================
func (q *Queries) GetPolicyVersion(ctx context.Context, arg GetPolicyVersionParams) (PolicyVersion, error) {
	row := q.db.QueryRow(ctx, getPolicyVersion, arg.PolicyName, arg.Version)
	var i PolicyVersion
	err := row.Scan(
		&i.ID,
		&i.PolicyName,
		&i.Version,
		&i.IsLatest,
		&i.DisplayName,
		&i.Provider,
		&i.Description,
		&i.Categories,
		&i.Tags,
		&i.LogoPath,
		&i.BannerPath,
		&i.SupportedPlatforms,
		&i.ReleaseDate,
		&i.DefinitionYaml,
		&i.IconPath,
		&i.SourceType,
		&i.SourceUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertPolicyVersion = `-- name: InsertPolicyVersion :one
INSERT INTO policy_version (
    policy_name,
    version,
    is_latest,
    display_name,
    provider,
    description,
    categories,
    tags,
    logo_path,
    banner_path,
    supported_platforms,
    release_date,
    definition_yaml,
    icon_path,
    source_type,
    source_url,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW(), NOW()
)
RETURNING id, policy_name, version, is_latest, display_name, provider, description, categories, tags, logo_path, banner_path, supported_platforms, release_date, definition_yaml, icon_path, source_type, source_url, created_at, updated_at
`

type InsertPolicyVersionParams struct {
	PolicyName         string      `json:"policy_name"`
	Version            string      `json:"version"`
	IsLatest           pgtype.Bool `json:"is_latest"`
	DisplayName        string      `json:"display_name"`
	Provider           string      `json:"provider"`
	Description        pgtype.Text `json:"description"`
	Categories         []byte      `json:"categories"`
	Tags               []byte      `json:"tags"`
	LogoPath           pgtype.Text `json:"logo_path"`
	BannerPath         pgtype.Text `json:"banner_path"`
	SupportedPlatforms []byte      `json:"supported_platforms"`
	ReleaseDate        pgtype.Date `json:"release_date"`
	DefinitionYaml     string      `json:"definition_yaml"`
	IconPath           pgtype.Text `json:"icon_path"`
	SourceType         pgtype.Text `json:"source_type"`
	SourceUrl          pgtype.Text `json:"source_url"`
}

func (q *Queries) InsertPolicyVersion(ctx context.Context, arg InsertPolicyVersionParams) (PolicyVersion, error) {
	row := q.db.QueryRow(ctx, insertPolicyVersion,
		arg.PolicyName,
		arg.Version,
		arg.IsLatest,
		arg.DisplayName,
		arg.Provider,
		arg.Description,
		arg.Categories,
		arg.Tags,
		arg.LogoPath,
		arg.BannerPath,
		arg.SupportedPlatforms,
		arg.ReleaseDate,
		arg.DefinitionYaml,
		arg.IconPath,
		arg.SourceType,
		arg.SourceUrl,
	)
	var i PolicyVersion
	err := row.Scan(
		&i.ID,
		&i.PolicyName,
		&i.Version,
		&i.IsLatest,
		&i.DisplayName,
		&i.Provider,
		&i.Description,
		&i.Categories,
		&i.Tags,
		&i.LogoPath,
		&i.BannerPath,
		&i.SupportedPlatforms,
		&i.ReleaseDate,
		&i.DefinitionYaml,
		&i.IconPath,
		&i.SourceType,
		&i.SourceUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPolicyVersions = `-- name: ListPolicyVersions :many

SELECT id, policy_name, version, is_latest, display_name, provider, description, categories, tags, logo_path, banner_path, supported_platforms, release_date, definition_yaml, icon_path, source_type, source_url, created_at, updated_at FROM policy_version
WHERE policy_name = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPolicyVersionsParams struct {
	PolicyName string `json:"policy_name"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

// =============================================================================
// POLICY VERSION LISTING & FILTERING
// =============================================================================
func (q *Queries) ListPolicyVersions(ctx context.Context, arg ListPolicyVersionsParams) ([]PolicyVersion, error) {
	rows, err := q.db.Query(ctx, listPolicyVersions, arg.PolicyName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PolicyVersion{}
	for rows.Next() {
		var i PolicyVersion
		if err := rows.Scan(
			&i.ID,
			&i.PolicyName,
			&i.Version,
			&i.IsLatest,
			&i.DisplayName,
			&i.Provider,
			&i.Description,
			&i.Categories,
			&i.Tags,
			&i.LogoPath,
			&i.BannerPath,
			&i.SupportedPlatforms,
			&i.ReleaseDate,
			&i.DefinitionYaml,
			&i.IconPath,
			&i.SourceType,
			&i.SourceUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLatestVersion = `-- name: UpdateLatestVersion :exec

UPDATE policy_version
SET is_latest = CASE
    WHEN policy_name = $1 AND version = $2 THEN TRUE
    ELSE FALSE
END
WHERE policy_name = $1
`

type UpdateLatestVersionParams struct {
	PolicyName string `json:"policy_name"`
	Version    string `json:"version"`
}

// =============================================================================
// POLICY VERSION MANAGEMENT
// =============================================================================
func (q *Queries) UpdateLatestVersion(ctx context.Context, arg UpdateLatestVersionParams) error {
	_, err := q.db.Exec(ctx, updateLatestVersion, arg.PolicyName, arg.Version)
	return err
}
